// @ts-nocheck
// screens/food/HomeScreen.js
// A scrolling screen that renders MerchantHeader inside the list header.
// Set options={{ headerShown: false }} for this screen in your navigator.

import React, { useCallback, useEffect, useMemo, useState } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Image,
  BackHandler,
  Platform,
  ActivityIndicator,
  FlatList,
} from 'react-native';
import Ionicons from 'react-native-vector-icons/Ionicons';
import { useNavigation, useFocusEffect, useRoute } from '@react-navigation/native';
import * as SecureStore from 'expo-secure-store';

// ❌ DO NOT import '@env' directly. It breaks parsing if not configured.
// import { DISPLAY_MENU_ENDPOINT as ENV_DISPLAY_MENU_ENDPOINT } from '@env';

// ✅ Safe optional load for @env (works even if plugin not set up)
let ENV_DISPLAY_MENU_ENDPOINT = '';
try {
  // eslint-disable-next-line global-require
  const e = require('@env');
  ENV_DISPLAY_MENU_ENDPOINT = e?.DISPLAY_MENU_ENDPOINT || '';
} catch {
  ENV_DISPLAY_MENU_ENDPOINT = '';
}

// If MerchantHeader.js is in the same folder:
import MerchantHeader from './MerchantHeader';
// If it's under components/, use:
// import MerchantHeader from '../../components/MerchantHeader';

/* ---------------- UI bits ---------------- */
const KpiCard = ({ icon, label, value, sub, isTablet }) => (
  <View style={[styles.kpiCard, { width: isTablet ? '23.5%' : '48%' }]}>
    <View style={styles.kpiIconWrap}>
      <Ionicons name={icon} size={isTablet ? 20 : 18} color="#0f172a" />
    </View>
    <Text style={[styles.kpiLabel, { fontSize: isTablet ? 13 : 12 }]}>{label}</Text>
    <Text style={[styles.kpiValue, { fontSize: isTablet ? 22 : 20 }]}>{value}</Text>
    {sub ? <Text style={[styles.kpiSub, { fontSize: isTablet ? 12 : 11 }]}>{sub}</Text> : null}
  </View>
);

const Shortcut = ({ icon, label, onPress = () => {}, isTablet }) => (
  <TouchableOpacity style={styles.shortcut} onPress={onPress} activeOpacity={0.9}>
    <View style={styles.shortcutIcon}>
      <Ionicons name={icon} size={isTablet ? 22 : 20} color="#0f172a" />
    </View>
    <Text style={[styles.shortcutText, { fontSize: isTablet ? 13 : 12 }]}>{label}</Text>
  </TouchableOpacity>
);

const MenuItem = ({ item, isTablet, money }) => {
  const price =
    typeof item?.price === 'number'
      ? money(item.price, item.currency || 'Nu')
      : item?.price ?? '';
  const inStock = item?.inStock ?? true;
  const cat = item?.category || item?.categoryName || '';

  return (
    <View style={styles.menuCard}>
      {item?.image ? (
        <Image source={{ uri: item.image }} style={styles.menuThumb} />
      ) : (
        <View style={[styles.menuThumb, styles.menuThumbFallback]}>
          <Ionicons name="image-outline" size={18} color="#64748b" />
        </View>
      )}

      <View style={{ flex: 1 }}>
        <Text numberOfLines={1} style={[styles.menuTitle, { fontSize: isTablet ? 15 : 14 }]}>
          {item?.name || item?.title || 'Unnamed item'}
        </Text>
        {cat ? (
          <Text numberOfLines={1} style={[styles.menuMeta, { fontSize: isTablet ? 12 : 11 }]}>
            {cat}
          </Text>
        ) : null}
        {price ? <Text style={[styles.menuPrice, { fontSize: isTablet ? 14 : 13 }]}>{price}</Text> : null}
      </View>

      <View style={[styles.stockPill, { backgroundColor: inStock ? '#dcfce7' : '#fee2e2' }]}>
        <Text
          style={[
            styles.stockText,
            { color: inStock ? '#166534' : '#991b1b', fontSize: isTablet ? 12 : 11 },
          ]}
        >
          {inStock ? 'In stock' : 'Out of stock'}
        </Text>
      </View>
    </View>
  );
};

/* ---------------- Utils ---------------- */
function getOrigin(url) {
  try {
    const u = new URL(url);
    return `${u.protocol}//${u.host}`;
  } catch {
    const m = String(url).match(/^(https?:\/\/[^/]+)/i);
    return m ? m[1] : '';
  }
}
function toAbsoluteUrl(origin, pathOrUrl) {
  if (!pathOrUrl) return '';
  const s = String(pathOrUrl);
  if (/^https?:\/\//i.test(s)) return s;
  const rel = s.startsWith('/') ? s : `/${s}`;
  return origin ? `${origin}${rel}` : rel;
}
function safeJoin(base, ...parts) {
  const a = String(base || '').replace(/\/+$/, '');
  const b = parts
    .map((p) => String(p || '').replace(/^\/+|\/+$/g, ''))
    .filter(Boolean)
    .join('/');
  return b ? `${a}/${b}` : a;
}

async function getStoredOwnerId() {
  try {
    const raw = await SecureStore.getItemAsync('merchant_login');
    if (!raw) return '';
    const json = JSON.parse(raw);
    const candidates = [json?.user?.id, json?.merchant?.id, json?.merchant_id, json?.owner_id, json?.id];
    const found = candidates.find((v) => v !== undefined && v !== null && String(v).trim() !== '');
    return found ? String(found) : '';
  } catch {
    return '';
  }
}

async function readErrorBody(res) {
  try {
    const text = await res.text();
    if (!text) return '';
    try {
      const j = JSON.parse(text);
      return typeof j?.message === 'string' ? j.message : JSON.stringify(j);
    } catch {
      return text;
    }
  } catch {
    return '';
  }
}

export default function HomeScreen({
  isTablet = false,
  kpis = {},
  menus = [],
  money: moneyProp,
}) {
  const navigation = useNavigation();
  const route = useRoute();

  const BUSINESS_ID_RAW = useMemo(() => {
    const p = route?.params ?? {};
    return (p.businessId || p.business_id || p.merchant?.businessId || p.merchant?.id || '')
      .toString()
      .trim();
  }, [route?.params]);

  const BUSINESS_ID = useMemo(() => {
    const n = parseInt(BUSINESS_ID_RAW, 10);
    return Number.isFinite(n) ? String(n) : String(BUSINESS_ID_RAW || '');
  }, [BUSINESS_ID_RAW]);

  const [ownerId, setOwnerId] = useState('');
  const [allMenus, setAllMenus] = useState(() => (Array.isArray(menus) ? menus : []));
  const [loading, setLoading] = useState(false);
  const [errorMsg, setErrorMsg] = useState('');

  useEffect(() => {
    (async () => setOwnerId(await getStoredOwnerId()))();
  }, []);

  useEffect(() => {
    (async () => {
      try {
        const storedMenus = await SecureStore.getItemAsync('menus');
        if (storedMenus) setAllMenus(JSON.parse(storedMenus));
      } catch (e) {
        console.error('Failed to load menus from SecureStore', e);
      }
    })();
  }, []);

  useEffect(() => {
    (async () => {
      try {
        if (allMenus.length > 0) {
          await SecureStore.setItemAsync('menus', JSON.stringify(allMenus));
        }
      } catch (e) {
        console.error('Failed to save menus to SecureStore', e);
      }
    })();
  }, [allMenus]);

  useFocusEffect(
    useCallback(() => {
      if (Platform.OS !== 'android') return undefined;
      const onBack = () => {
        if (navigation.canGoBack()) {
          navigation.goBack();
          return true;
        }
        return false;
      };
      const sub = BackHandler.addEventListener('hardwareBackPress', onBack);
      return () => sub.remove();
    }, [navigation])
  );

  const DISPLAY_MENU_ENDPOINT = useMemo(
    () => (ENV_DISPLAY_MENU_ENDPOINT || '').replace(/\/+$/, ''),
    []
  );
  const API_ORIGIN = useMemo(() => getOrigin(DISPLAY_MENU_ENDPOINT), [DISPLAY_MENU_ENDPOINT]);

  const extractItemsFromResponse = useCallback((raw) => {
    if (Array.isArray(raw)) return raw;
    if (Array.isArray(raw?.data)) return raw.data;
    const candidates = ['items', 'rows', 'result', 'payload', 'list', 'menus', 'menu'];
    for (const k of candidates) if (Array.isArray(raw?.[k])) return raw[k];
    if (raw && typeof raw === 'object') {
      for (const v of Object.values(raw)) if (Array.isArray(v)) return v;
    }
    return [];
  }, []);

  const normalizeItem = useCallback((x, idx = 0) => {
    const numericActual = Number(x?.actual_price);
    const numericBase = Number(x?.base_price);
    const price = Number.isFinite(numericActual)
      ? numericActual
      : Number.isFinite(numericBase)
        ? numericBase
        : (typeof x?.price === 'number' ? x.price : Number(x?.price ?? 0));

    const absImage = toAbsoluteUrl(
      API_ORIGIN,
      x?.image_url ?? x?.item_image_url ?? x?.item_image ?? x?.image ?? ''
    );

    const bizId =
      x?.business_id ?? x?.businessId ?? x?.merchant_business_id ?? x?.restaurant_id ?? x?.store_id;
    const ownId =
      x?.owner_id ?? x?.ownerId ?? x?.merchant_id ?? x?.merchantId ?? x?.created_by ?? x?.user_id;

    return {
      id: String(x?.id ?? x?._id ?? x?.menu_id ?? idx),
      name: x?.item_name ?? x?.name ?? x?.title ?? 'Unnamed item',
      title: x?.title ?? undefined,
      price,
      discount: x?.discount_percentage ?? '',
      taxRate: x?.tax_rate ?? '',
      currency: x?.currency ?? 'Nu',
      inStock: (x?.is_available ?? x?.inStock ?? 1) ? true : false,
      category: x?.category_name ?? x?.category ?? x?.categoryName ?? '',
      categoryName: x?.category_name ?? x?.category ?? x?.categoryName ?? '',
      image: absImage,
      description: x?.description ?? '',
      businessId: bizId ? String(bizId) : '',
      ownerId: ownId ? String(ownId) : '',
      _raw: x,
    };
  }, [API_ORIGIN]);

  const filterMenusForOwner = useCallback((arr) => {
    if (!ownerId && !BUSINESS_ID) return arr;
    return arr.filter((it) => {
      const matchBusiness = BUSINESS_ID ? String(it.businessId || '') === String(BUSINESS_ID) : true;
      const matchOwner   = ownerId     ? String(it.ownerId   || '') === String(ownerId)       : true;
      return matchBusiness && matchOwner;
    });
  }, [ownerId, BUSINESS_ID]);

  const buildCandidateUrls = useCallback(() => {
    if (!DISPLAY_MENU_ENDPOINT) return [];
    const base = DISPLAY_MENU_ENDPOINT.replace(/\/+$/, '');
    const hasBusinessSuffix = /\/business$/i.test(base);
    const root = hasBusinessSuffix ? base.replace(/\/business$/i, '') : base;

    const id = BUSINESS_ID && /^\d+$/.test(BUSINESS_ID) ? BUSINESS_ID : '';
    const own = ownerId ? String(ownerId) : '';

    const withQS = (u, qsObj = {}) => {
      const params = new URLSearchParams();
      Object.entries(qsObj).forEach(([k, v]) => {
        if (v !== undefined && v !== null && String(v).trim() !== '') params.set(k, String(v));
      });
      const qs = params.toString();
      return qs ? `${u}?${qs}` : u;
    };

    const urls = [];

    if (hasBusinessSuffix && id) {
      urls.push(safeJoin(base, id)); // .../business/17
    }

    const qsCandidates = [
      { business_id: id, ownerId: own },
      { businessId: id, ownerId: own },
      { merchant_business_id: id, ownerId: own },
      { restaurant_id: id, ownerId: own },
      own ? { ownerId: own } : null,
    ].filter(Boolean);

    const pathCandidates = [root, safeJoin(root, 'menu'), safeJoin(root, 'display')];

    pathCandidates.forEach((p) => {
      qsCandidates.forEach((q) => urls.push(withQS(p, q)));
    });

    const dedup = [];
    const seen = new Set();
    for (const u of urls) {
      if (!seen.has(u)) { seen.add(u); dedup.push(u); }
    }
    return dedup;
  }, [DISPLAY_MENU_ENDPOINT, BUSINESS_ID, ownerId]);

  const tryFetchOnce = useCallback(async (url, token) => {
    const controller = new AbortController();
    const tid = setTimeout(() => controller.abort(), 15000);
    try {
      const res = await fetch(url, {
        method: 'GET',
        headers: {
          Accept: 'application/json',
          ...(token ? { Authorization: `Bearer ${token}` } : {}),
          ...(BUSINESS_ID ? { 'X-Business-Id': String(BUSINESS_ID) } : {}),
          ...(ownerId ? { 'X-Owner-Id': String(ownerId) } : {}),
        },
        signal: controller.signal,
      });

      if (!res.ok) {
        const body = await readErrorBody(res);
        const msg = `HTTP ${res.status}${body ? ` — ${body}` : ''}`;
        throw new Error(msg);
      }

      const text = await res.text();
      let parsed = [];
      try { parsed = text ? JSON.parse(text) : []; } catch { parsed = []; }
      const items = extractItemsFromResponse(parsed);
      const normalized = items.map((x, i) => normalizeItem(x, i));
      return normalized;
    } finally {
      clearTimeout(tid);
    }
  }, [extractItemsFromResponse, normalizeItem, BUSINESS_ID, ownerId]);

  const fetchMenus = useCallback(async () => {
    if (!DISPLAY_MENU_ENDPOINT) {
      setErrorMsg('Missing DISPLAY_MENU_ENDPOINT in .env');
      return;
    }

    setLoading(true);
    setErrorMsg('');
    try {
      const token = (await SecureStore.getItemAsync('auth_token')) || '';
      const candidates = buildCandidateUrls();

      if (candidates.length === 0) {
        setErrorMsg('Missing businessId. Pass it via route params.');
        setLoading(false);
        return;
      }

      const errors = [];
      for (const url of candidates) {
        try {
          const normalized = await tryFetchOnce(url, token);
          const filtered = filterMenusForOwner(normalized);
          if (filtered.length === 0) {
            setAllMenus([]);
            setErrorMsg('No items available for your account.');
          } else {
            setAllMenus(filtered);
            setErrorMsg('');
          }
          return; // success
        } catch (e) {
          errors.push(`• ${url} -> ${e.message}`);
        }
      }

      setErrorMsg(`Error fetching menus:\n${errors.join('\n')}`);
      console.error('Menu fetch failures:\n' + errors.join('\n'));
    } catch (e) {
      setErrorMsg(`Unexpected error: ${e.message}`);
      console.error('Unexpected fetch error:', e);
    } finally {
      setLoading(false);
    }
  }, [DISPLAY_MENU_ENDPOINT, buildCandidateUrls, filterMenusForOwner, tryFetchOnce]);

  const didFetchRef = React.useRef(false);
  useFocusEffect(
    useCallback(() => {
      if (didFetchRef.current) return;
      didFetchRef.current = true;
      fetchMenus();
      return () => { didFetchRef.current = false; };
    }, [fetchMenus])
  );

  const fmtMoney = useCallback(
    (n, ccy = 'Nu') =>
      (typeof moneyProp === 'function' ? moneyProp(n, ccy) : `${ccy} ${Number(n || 0).toFixed(2)}`),
    [moneyProp]
  );
  const pct = useCallback((v) => `${Math.round((Number.isFinite(v) ? v : 0) * 100)}%`, []);

  const salesToday = Number(kpis?.salesToday ?? 0);
  const salesCurrency = kpis?.salesCurrency || 'Nu';
  const activeOrders = Number(kpis?.activeOrders ?? 0);
  const acceptanceRate = Number.isFinite(kpis?.acceptanceRate) ? kpis.acceptanceRate : 0;
  const cancellations = Number(kpis?.cancellations ?? 0);

  const keyExtractor = useCallback(
    (item, i) => String(item?.id ?? item?._id ?? item?.slug ?? item?.name ?? i),
    []
  );
  const renderItem = useCallback(
    ({ item }) => <MenuItem isTablet={isTablet} money={fmtMoney} item={item} />,
    [isTablet, fmtMoney]
  );

  const visibleMenus = useMemo(() => allMenus.slice(0, 3), [allMenus]);
  const showCountNote = allMenus.length > 3;

  const HeaderAfterGradient = useMemo(() => (
    <View>
      <View style={[styles.kpiRow, { marginHorizontal: isTablet ? 20 : 12, marginTop: isTablet ? 20 : 16 }]}>
        <KpiCard isTablet={isTablet} icon="cash-outline"           label="Today"  value={fmtMoney(salesToday, salesCurrency)} sub="Sales" />
        <KpiCard isTablet={isTablet} icon="receipt-outline"        label="Active" value={String(activeOrders)}               sub="Orders" />
        <KpiCard isTablet={isTablet} icon="trending-up-outline"    label="Accept" value={pct(acceptanceRate)}                sub="Rate" />
        <KpiCard isTablet={isTablet} icon="alert-circle-outline"   label="Cancel" value={String(cancellations)}              sub="Today" />
      </View>

      <View style={styles.section}>
        <View style={styles.sectionHead}>
          <Text style={[styles.sectionTitle, { fontSize: isTablet ? 18 : 16 }]}>Quick actions</Text>
          <TouchableOpacity style={styles.linkRow} onPress={() => {}}>
            <Text style={[styles.linkText, { fontSize: isTablet ? 14 : 13 }]}>Manage</Text>
            <Ionicons name="chevron-forward" size={isTablet ? 18 : 16} color="#00b14f" />
          </TouchableOpacity>
        </View>

        <View style={[styles.shortcutsRow, { flexWrap: 'wrap' }]}>
          <Shortcut
            isTablet={isTablet}
            icon="restaurant-outline"
            label="Menu"
            onPress={() => navigation.navigate('MenuScreen', { businessId: BUSINESS_ID || 'YOUR_BUSINESS_ID' })}
          />
          <Shortcut isTablet={isTablet} icon="pricetags-outline" label="Promotions" onPress={() => navigation.navigate('Promos')} />
          <Shortcut isTablet={isTablet} icon="card-outline"      label="Payouts"     onPress={() => navigation.navigate('Payouts')} />
          <Shortcut isTablet={isTablet} icon="settings-outline"  label="Settings"    onPress={() => navigation.navigate('AccountSettings')} />
        </View>
      </View>

      <View style={styles.section}>
        <View style={styles.sectionHead}>
          <Text style={[styles.sectionTitle, { fontSize: isTablet ? 18 : 16 }]}>Added menus</Text>
          <TouchableOpacity
            style={styles.linkRow}
            onPress={() => navigation.navigate('MenuScreen', { businessId: BUSINESS_ID || 'YOUR_BUSINESS_ID' })}
          >
            <Text style={[styles.linkText, { fontSize: isTablet ? 14 : 13 }]}>View all</Text>
            <Ionicons name="chevron-forward" size={isTablet ? 18 : 16} color="#00b14f" />
          </TouchableOpacity>
        </View>
        {showCountNote ? <Text style={styles.countNote}>Showing 3 of {allMenus.length} items</Text> : null}
      </View>
    </View>
  ), [
    isTablet, fmtMoney, salesToday, salesCurrency, activeOrders,
    acceptanceRate, cancellations, pct, navigation, BUSINESS_ID,
    allMenus.length, showCountNote
  ]);

  const ListHeader = useMemo(() => (
    <>
      <MerchantHeader />
      {HeaderAfterGradient}
    </>
  ), [HeaderAfterGradient]);

  const ListFooter = useMemo(() => (
    <View>
      <View style={[styles.section, { marginBottom: 75 }]}>
        <View style={styles.sectionHead}>
          <Text style={[styles.sectionTitle, { fontSize: isTablet ? 18 : 16 }]}>Announcements</Text>
        </View>
        <View style={styles.announce}>
          <Ionicons name="megaphone-outline" size={isTablet ? 20 : 18} color="#0f172a" />
          <View style={{ flex: 1 }}>
            <Text style={[styles.announceTitle, { fontSize: isTablet ? 15 : 14 }]}>Lower delivery fees this weekend</Text>
            <Text style={[styles.announceSub, { fontSize: isTablet ? 13 : 12 }]}>
              Expect higher demand from Fri–Sun. Prep your inventory and staff.
            </Text>
          </View>
          <TouchableOpacity style={styles.badge} onPress={() => {}}>
            <Text style={[styles.badgeText, { fontSize: isTablet ? 12 : 11 }]}>Details</Text>
          </TouchableOpacity>
        </View>
      </View>
    </View>
  ), [isTablet]);

  const Empty = useMemo(() => {
    if (loading) {
      return (
        <View style={[styles.section, styles.emptyBox]}>
          <ActivityIndicator />
          <Text style={[styles.emptySub, { marginTop: 6 }]}>Loading menu items…</Text>
        </View>
      );
    }
    if (errorMsg) {
      return (
        <View style={[styles.section, styles.emptyBox]}>
          <Ionicons name="warning-outline" size={20} color="#ef4444" />
          <Text style={[styles.emptyTitle, { color: '#ef4444' }]} selectable>
            {errorMsg}
          </Text>
          <TouchableOpacity onPress={fetchMenus} style={[styles.badge, { marginTop: 8 }]}>
            <Text style={styles.badgeText}>Retry</Text>
          </TouchableOpacity>
        </View>
      );
    }
    return (
      <View style={[styles.section, styles.emptyBox]}>
        <Ionicons name="fast-food-outline" size={isTablet ? 30 : 28} color="#0f172a" />
        <Text style={[styles.emptyTitle, { fontSize: isTablet ? 15 : 14 }]}>No menu items yet</Text>
        <Text style={[styles.emptySub, { fontSize: isTablet ? 13 : 12 }]}>Add your first item to start selling.</Text>
      </View>
    );
  }, [loading, errorMsg, fetchMenus, isTablet]);

  return (
    <View style={{ flex: 1, backgroundColor: '#f6f7f8' }}>
      <FlatList
        data={visibleMenus}
        keyExtractor={keyExtractor}
        renderItem={renderItem}
        ItemSeparatorComponent={() => <View style={{ height: 12, marginHorizontal: 16 }} />}

        ListHeaderComponent={ListHeader}
        ListFooterComponent={ListFooter}
        ListEmptyComponent={Empty}

        contentContainerStyle={{ paddingBottom: 24 }}
        scrollEnabled
        nestedScrollEnabled={false}
        removeClippedSubviews={false}
        refreshing={loading}
        onRefresh={fetchMenus}
      />
    </View>
  );
}

/* ---------------- styles ---------------- */
const styles = StyleSheet.create({
  section: { marginTop: 16, paddingHorizontal: 16 },
  sectionHead: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 10 },
  sectionTitle: { fontWeight: '700', color: '#0f172a' },
  linkRow: { flexDirection: 'row', alignItems: 'center', gap: 4 },
  linkText: { color: '#00b14f', fontWeight: '600' },
  countNote: { color: '#64748b', marginTop: -6, paddingHorizontal: 2 },

  kpiRow: { marginTop: -10, backgroundColor: 'transparent', flexDirection: 'row', flexWrap: 'wrap', gap: 8 },
  kpiCard: {
    backgroundColor: '#fff', borderRadius: 16, padding: 14,
    shadowColor: '#000', shadowOpacity: 0.06, shadowRadius: 8, shadowOffset: { width: 0, height: 2 }, elevation: 2,
  },
  kpiIconWrap: { alignSelf: 'flex-start', padding: 8, borderRadius: 999, backgroundColor: '#f1f5f9', marginBottom: 8 },
  kpiLabel: { color: '#6b7280' },
  kpiValue: { fontWeight: '700', marginTop: 2, color: '#0f172a' },
  kpiSub: { color: '#9ca3af', marginTop: 2 },

  shortcutsRow: { flexDirection: 'row', gap: 12, paddingHorizontal: 16 },
  shortcut: {
    flex: 1,
    backgroundColor: '#fff',
    borderRadius: 16,
    paddingVertical: 14,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOpacity: 0.05,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 2 },
    elevation: 2,
    marginHorizontal: 0,
  },
  shortcutIcon: { padding: 10, borderRadius: 999, backgroundColor: '#f1f5f9', marginBottom: 8 },
  shortcutText: { fontWeight: '600', color: '#0f172a' },

  menuCard: {
    backgroundColor: '#fff', borderRadius: 16, padding: 14, flexDirection: 'row', alignItems: 'center', gap: 12,
    shadowColor: '#000', shadowOpacity: 0.06, shadowRadius: 8, shadowOffset: { width: 0, height: 2 }, elevation: 2,
    marginHorizontal: 16,
  },
  menuThumb: { width: 48, height: 48, borderRadius: 8, backgroundColor: '#e2e8f0' },
  menuThumbFallback: { alignItems: 'center', justifyContent: 'center' },
  menuTitle: { fontWeight: '700', color: '#111827' },
  menuMeta: { color: '#6b7280', marginTop: 2 },
  menuPrice: { color: '#0f172a', fontWeight: '700', marginTop: 4 },
  stockPill: { paddingHorizontal: 10, paddingVertical: 6, borderRadius: 999, marginLeft: 8 },
  stockText: { fontWeight: '700' },

  emptyBox: { backgroundColor: '#fff', borderRadius: 16, padding: 24, alignItems: 'center', gap: 6, marginHorizontal: 16 },
  emptyTitle: { fontWeight: '700', color: '#0f172a' },
  emptySub: { color: '#6b7280' },

  announce: {
    backgroundColor: '#fff', borderRadius: 16, padding: 14, flexDirection: 'row', alignItems: 'center',
    gap: 12,
    shadowColor: '#000', shadowOpacity: 0.05, shadowRadius: 8, shadowOffset: { width: 0, height: 2 }, elevation: 2,
    marginHorizontal: 0,
  },
  announceTitle: { fontWeight: '700', color: '#0f172a' },
  announceSub: { color: '#475569' },
  badge: { paddingHorizontal: 10, paddingVertical: 6, borderRadius: 999, backgroundColor: '#00b14f' },
  badgeText: { color: '#fff', fontWeight: '700' },
});
